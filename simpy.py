# -*- coding: utf-8 -*-
"""Simpy4-5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jHStiThkdP3PsWiYkZLsyYId7I8kfd5v
"""

pip install simpy

"""# RESUMEN TUTORIAL SIMPY

* active components (vehicles, customers, messages) is modeled with *processes*.
 
* All processes live in an *enviroment*

* processes interact with the enviroment and with each other via *events*


Processes ->generators: create events and yield them to wait for them to be triggered. When a process yields an event, it gets suspended. Simpy resumens the process when the event occurs.

Timeout: event triggered after certain amount of time has passed
"""

#la referencia a env es para crear nuevos eventos. si bien es loop infinito, pasa flujo de programa cuando llega a yield, retoma
#cuando el evento es triggereado

def car(env):
     while True:
         print('Start parking at %d' % env.now)
         parking_duration = 5
         yield env.timeout(parking_duration)

         print('Start driving at %d' % env.now)
         trip_duration = 2
         yield env.timeout(trip_duration)

import simpy

env = simpy.Environment() #creo env
env.process(car(env)) #agrego el proceso car al env (lo que devuelve se puede usar para interactuar)
env.run(until=15) #paso tiempo final

"""lo que retorna process se puede usar para interactuar: esperar a que otro proceso termine o interrumpir a otro proceso mientras espera por un evento. Se puede usar un process como un event."""

class Car(object):
    def __init__(self, env):
        self.env = env
        # Start the run process everytime an instance is created.
        self.action = env.process(self.run())
    def run(self):
        while True:
            print('Start parking and charging at %d' % self.env.now)
            charge_duration = 5
            # We yield the process that process() returns
            # to wait for it to finish
            yield self.env.process(self.charge(charge_duration))
            # The charge process has finished and
            # we can start driving again.
            print('Start driving at %d' % self.env.now)
            trip_duration = 2
            yield self.env.timeout(trip_duration)
    def charge(self, duration):
        yield self.env.timeout(duration)

env = simpy.Environment()
car = Car(env)
env.run(until=15)

"""se puede interrumpir con interrupt(). En este caso interrumpe al auto luego de 3 steps. Se le tira la excepcion al auto y él la maneja"""

def driver(env, car):
     yield env.timeout(3)
     car.action.interrupt()

class Car(object):
    def __init__(self, env):
        self.env = env
        # Start the run process everytime an instance is created.
        self.action = env.process(self.run())
    def run(self):
        while True:
            print('Start parking and charging at %d' % self.env.now)
            charge_duration = 5
            # We may get interrupted while charging the battery
            try:
                yield self.env.process(self.charge(charge_duration))
            except simpy.Interrupt:
                # When we received an interrupt, we stop charging and
                # switch to the "driving" state
                print('Was interrupted. Hope, the battery is full enough ...')            
            print('Start driving at %d' % self.env.now)
            trip_duration = 2
            yield self.env.timeout(trip_duration)
    def charge(self, duration):
        yield self.env.timeout(duration)

"""Recursos compartidos (muchos procesos quieren usar algo con capacidad limitada)"""

def car(env, name, bcs, driving_time, charge_duration):
    # Simulate driving to the BCS
    yield env.timeout(driving_time)
    # Request one of its charging spots
    print('%s arriving at %d' % (name, env.now))
    with bcs.request() as req:
        yield req
        # Charge the battery
        print('%s starting to charge at %s' % (name, env.now))
        yield env.timeout(charge_duration)
        print('%s leaving the bcs at %s' % (name, env.now))

"""request crea evento que permite esperar a que se libere recurso. Con el llamada a with el recurso se libera cuando terminas, sino tenes que hacer un release manual (como el with open de archivos). El resource básico es una FIFO"""

import simpy
env = simpy.Environment()
bcs = simpy.Resource(env, capacity=2) #bcs es la estacion para cargar bateria

for i in range(4):
     env.process(car(env, 'Car %d' % i, bcs, i*2, 5))

env.run()

"""# RESOLUCION DE EJERCICIOS

Los instantes de tiempo en 4 serán en minutos

# Ejercicio 4

Horarios:

* 10 h - 12 h | 0 - 120 min -> 240 s de media -> 4 min
* 12 h - 15 h | 120 min - 300 min -> 120 s de media -> 2 min
* 15 h - 19 h | 300 min - 540 min -> 360 s de media -> 6 min

Clientes:

1. Con proba 0.1 -> 4+-3 tiempo de proceso
2. Con proba 0.7 -> 2+-1 tiempo de proceso
3. Con proba 0.2 -> 3+-2 tiempo de proceso

Defino al cliente que recibe el environment, nombre (nro de arribo), el resource y el tiempo de uso del atm. El tiempo de uso se determina de acuerdo a las probabilidades del cuadro.

Cada cliente arribará de acuerdo a una tasa de arribos. Esto se encuentra definido en arribals que hace un yield de acuerdo a esa tasa y luego genera un cliente, pasandole el recurso
"""

def client(env, name, atm, time_use_atm):
    arrive_time = env.now
    print('%s arriving at the ATM at %.2f '  % (name, arrive_time))
    queue_size.append(len(atm.queue)) # largo de la fila en este instante
    time.append(arrive_time) # tiempo de arribo
    with atm.request() as req:
        yield req
        use_atm = env.now
        waiting_time.append(use_atm - arrive_time)
        print('%s starting to use ATM at %.2f' % (name, use_atm))
        yield env.timeout(time_use_atm)
        print('%s leaving the ATM at %.2f' % (name, env.now))


def arrivals(env, atm):
  i = 0
  while True:
    mean = get_mean(env.now)
    yield env.timeout(random.expovariate(1/mean))
    env.process(client(env, 'Client %d' % i, atm, get_client_atm_time()))
    i +=1

def get_client_atm_time():
  u = random.uniform(0,1)
  if u < 0.1:
    return random.uniform(1, 7)
  elif u >= 0.1 and u < 0.8:
    return random.uniform(1, 3)
  else:
    return random.uniform(1, 5)



def get_mean(time):
  if (time < 120):
    return 4
  elif time >=120 and time < 300:
    return 2
  elif time >=300:
    return 6

import random 
import simpy
import matplotlib.pyplot as plt

SEED = 100815

global time
time = []
global queue_size
queue_size = []
global waiting_time
waiting_time = []


random.seed(SEED)


env = simpy.Environment()
atm = simpy.Resource(env, capacity=1) 
env.process(arrivals(env, atm))
env.run(until = 540)


plt.plot(time, queue_size)
plt.plot(time, waiting_time)

"""Se puede observar en azul la cantidad de clientes en fila dado un instante de tiempo y en naranja el tiempo de espera si se llegara en ese instante de tiempo."""

print("MAXIMA FILA: ",max(queue_size))
print("MAXIMO TIEMPO DE ESPERA", max(waiting_time)) # aprox 1 hs

"""Para chequear teoricamente la cantidad de arribos

"""

random.seed(SEED)

def generate_arrivals(mean, time_interval):
  total_time = 0
  time_between_arrivals = []
  while (total_time < time_interval):
    time = random.expovariate(1/mean)
    if (time + total_time > time_interval):
      break 
    total_time += time
    time_between_arrivals.append(time)
  time_of_arrivals = [time_between_arrivals[0]]
  for i in range(1,len(time_between_arrivals)):
    time_of_arrivals.append(time_between_arrivals[i] + time_of_arrivals[i-1])
  return time_of_arrivals


print(len(generate_arrivals(4,120)) + len(generate_arrivals(2,180)) + len(generate_arrivals(6,240)))

"""# Ejercicio 5

* Arriban solicitudes segun exponencial negativa de media 45 ms
* 5 servidores
* 1 balanceador

* Tiempo procesamiento:
  * A (p = 0.7): 120 +- 60 ms
  * B (p = 0.2): 240 +- 120 ms
  * C (p = 0.1): 500 +- 300 ms

El balanceador tiene 2 politicas de distribucion: round robin, que implica obtener el numero de servidor de esa manera; y optima, que implica obtenerlo de acuerdo al punto *a* de la consigna. A su vez tiene el environment y los servers (5 recursos de capacidad 1).

La solicitud, de igual manera que el cliente, llega y la "intercepta" el balanceador y le asigna un servidor. Luego la solicitud hace un request al servidor para usarlo y lo usa inmediatamente o aguarda en la fila del mismo.

Los arribos se determinan de acuerdo a la tasa, esto se ve tanto en round_robin_distribution como en optimal_distribution.
"""

import numpy

class Balancer(object):
    def __init__(self, env, servers):
        self.env = env
        self.servers = servers
        self.round_robin_server = 0
        self.i = 0

    def get_round_robin_server(self):
      if (self.round_robin_server == 5):
        self.round_robin_server = 0
        return 5
      else: 
        self.round_robin_server += 1
        return self.round_robin_server - 1

    def round_robin_distribution(self):
      while True:
        yield env.timeout(random.expovariate(1.0/45.0))
        number_server = self.get_round_robin_server()
        env.process(request('Request %d' % i, env, servers[number_server], number_server, get_time_process()))
        self.i += 1     

    def get_optimal_server(self):
      min_queue = numpy.inf
      min_queue_number = 0
      for i in range(len(servers)):
        if (servers_current_queue[i] < min_queue):
          min_queue = servers_current_queue[i]
          min_queue_number = i
      return min_queue_number

    def optimal_distribution(self):
      while True:
        yield env.timeout(random.expovariate(1.0/45.0))
        number_server = self.get_optimal_server()
        servers_current_queue[number_server] += 1
        env.process(request('Request %d' % i, env, servers[number_server], number_server, get_time_process()))
        self.i += 1
             
    def get_total_req(self):
      return self.i 

def get_time_process():
  u = random.uniform(0,1)
  if u < 0.7:
    return random.uniform(120-60, 120+60)
  elif u >= 0.7 and u < 0.9:
    return random.uniform(240-120, 240+120)
  else:
    return random.uniform(500-300, 500+300)

def request(name, env, server, n_server,time_process):
    arrive_time = env.now
    #print('%s arriving at %d server at %.2f '  % (name, n_server,arrive_time))
    servers_queue[n_server].append(len(server.queue))
    time[n_server].append(arrive_time)
    with server.request() as req:
        yield req
        servers_wait_time[n_server].append(env.now - arrive_time)
        #print('%s starting to use server at %.2f' % (name, env.now))
        yield env.timeout(time_process)
        #print('%s leaving the server at %.2f' % (name, env.now))
        servers_current_queue[n_server] -= 1

ITER = 100000
import random 
import simpy
import matplotlib.pyplot as plt

N_SERVERS = 6

servers_current_queue = [0 for i in range(N_SERVERS)]
servers_queue = [[] for i in range(N_SERVERS)]
time = [[] for i in range(ITER)]
servers_wait_time = [[] for i in range(N_SERVERS)]


random.seed(SEED)
env = simpy.Environment()
servers = [simpy.Resource(env, capacity=1) for i in range(N_SERVERS)]
balancer = Balancer(env, servers)

env.process(balancer.round_robin_distribution())
env.run(until = ITER)





plt.figure(figsize=(30,10))
for i in range(N_SERVERS):
  plt.plot(time[i],servers_queue[i], label='server %d'% (i+1))
  plt.legend(loc='upper right')
  
total_time_waiting = sum(sum(server_time) for server_time in servers_wait_time)
total_request = balancer.get_total_req()
print("TOTAL TIME WAITING", total_time_waiting)
print("TOTAL REQUESTS", total_request)
print("TOTAL REQUESTS IN QUEUE", sum(sum(server_queue_state) for server_queue_state in servers_queue))
print("MAX TIME WATING", max(max(server_time) for server_time in servers_wait_time))
print("MEAN WAITING TIME", total_time_waiting / total_request)

servers_current_queue = [0 for i in range(N_SERVERS)]
servers_queue = [[] for i in range(N_SERVERS)]
servers_wait_time = [[] for i in range(N_SERVERS)]
time = [[] for i in range(ITER)]

random.seed(SEED)
env = simpy.Environment()
servers = [simpy.Resource(env, capacity=1) for i in range(N_SERVERS)]

balancer = Balancer(env, servers)


env.process(balancer.optimal_distribution())

env.run(until = ITER)
plt.figure(figsize=(30,10))
for i in range(N_SERVERS):
  plt.plot(time[i],servers_queue[i], label='server %d'% (i+1))
  plt.legend(loc='upper right')

total_time_waiting = sum(sum(server_time) for server_time in servers_wait_time)
total_request = balancer.get_total_req()
print("TOTAL TIME WAITING", total_time_waiting)
print("TOTAL REQUESTS", total_request)
print("TOTAL REQUESTS IN QUEUE", sum(sum(server_queue_state) for server_queue_state in servers_queue))
print("MAX TIME WATING", max(max(server_time) for server_time in servers_wait_time))
print("MEAN WAITING TIME", total_time_waiting / total_request)

"""Se observa que es ampliamente mejor la forma óptima, tanto en los picos de fila, como en los tiempo de espera promedio y totales."""